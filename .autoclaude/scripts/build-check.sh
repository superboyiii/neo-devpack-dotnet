#!/bin/bash
# Build Check
# Ensures the project can build successfully
# Auto-generated by AutoClaude

set -euo pipefail

# Initialize arrays
declare -a errors=()
declare -a build_commands=()

# Detect build system and set commands
if [ -f "package.json" ]; then
    # Node.js project
    if [ -f "package-lock.json" ] || [ -f "yarn.lock" ] || [ -f "pnpm-lock.yaml" ]; then
        if command -v npm &> /dev/null && [ -f "package-lock.json" ]; then
            build_commands+=("npm run build" "npm run compile")
        elif command -v yarn &> /dev/null && [ -f "yarn.lock" ]; then
            build_commands+=("yarn build" "yarn compile")
        elif command -v pnpm &> /dev/null && [ -f "pnpm-lock.yaml" ]; then
            build_commands+=("pnpm build" "pnpm compile")
        fi
    fi
elif [ -f "Cargo.toml" ]; then
    # Rust project
    build_commands+=("cargo build" "cargo check")
elif [ -f "go.mod" ]; then
    # Go project
    build_commands+=("go build ./...")
elif [ -f "pom.xml" ]; then
    # Maven project
    build_commands+=("mvn compile")
elif [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
    # Gradle project
    build_commands+=("gradle build")
elif [ -f "Makefile" ] || [ -f "makefile" ]; then
    # Make-based project
    build_commands+=("make" "make build")
elif [ -f "CMakeLists.txt" ]; then
    # CMake project
    build_commands+=("cmake . && make")
elif [ -f "requirements.txt" ] || [ -f "setup.py" ] || [ -f "pyproject.toml" ]; then
    # Python project - check syntax
    build_commands+=("python -m py_compile **/*.py")
fi

# Try to find build command in package.json scripts
if [ -f "package.json" ] && command -v jq &> /dev/null; then
    # Extract available build-related scripts
    scripts=$(jq -r '.scripts | keys[]' package.json 2>/dev/null | grep -E '^(build|compile|tsc)' || true)
    for script in $scripts; do
        if command -v npm &> /dev/null; then
            build_commands+=("npm run $script")
        fi
    done
fi

# Remove duplicates from build_commands
build_commands=($(printf "%s\n" "${build_commands[@]}" | sort -u))

# Function to run a build command
run_build_command() {
    local cmd="$1"
    local output
    local exit_code
    
    echo "Running: $cmd" >&2
    
    # Run command and capture output
    if output=$(eval "$cmd" 2>&1); then
        echo "✓ Build command succeeded: $cmd" >&2
        return 0
    else
        exit_code=$?
        echo "✗ Build command failed: $cmd (exit code: $exit_code)" >&2
        # Extract meaningful error lines
        echo "$output" | grep -E "(error|Error|ERROR|failed|Failed|FAILED)" | head -20 | while IFS= read -r line; do
            errors+=("$cmd: $line")
        done
        return 1
    fi
}

# Run build commands
build_succeeded=false
for cmd in "${build_commands[@]}"; do
    if run_build_command "$cmd"; then
        build_succeeded=true
        break
    fi
done

# If no build commands were found or all failed
if [ ${#build_commands[@]} -eq 0 ]; then
    errors+=("No build system detected. Please ensure your project has a build configuration.")
elif [ "$build_succeeded" = false ]; then
    errors+=("All build commands failed. Project cannot be built successfully.")
fi

# Function to escape JSON strings
json_escape() {
    printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g; s/
/\\n/g; s//\\r/g'
}

# Function to escape JSON strings
json_escape() {
    printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g; s/
/\\n/g; s//\\r/g'
}

# Output results in JSON format
echo "{"
echo "  \"passed\": $([ ${#errors[@]} -eq 0 ] && echo "true" || echo "false"),"
echo "  \"errors\": ["
if [ ${#errors[@]} -gt 0 ]; then
    for i in "${!errors[@]}"; do
        echo -n "    \"$(json_escape "${errors[$i]}")\"" 
        if [ $i -lt $((${#errors[@]} - 1)) ]; then
            echo ","
        else
            echo
        fi
    done
fi
echo "  ],"
echo "  \"fixInstructions\": \"Fix all build errors. Ensure all dependencies are installed and the project compiles without errors.\""
echo "}"
