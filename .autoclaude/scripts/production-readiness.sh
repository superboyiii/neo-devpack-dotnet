#!/bin/bash
# Production Readiness Check
# Checks for TODO, FIXME, placeholders, and incomplete implementations
# Auto-generated by AutoClaude

set -euo pipefail

# Initialize arrays for errors and warnings
declare -a errors=()
declare -a warnings=()

# Patterns that indicate incomplete or non-production code
patterns=(
    "TODO"
    "FIXME"
    "PLACEHOLDER"
    "XXX"
    "HACK"
    "temporary"
    "quick[[:space:]]+fix"
    "for[[:space:]]+now"
    "simplified"
    "\.\.\..*$"
    "<<<|>>>"
    "not[[:space:]]+implemented"
    "throw[[:space:]]+new[[:space:]]+Error.*not[[:space:]]+implemented"
    "console\.(log|debug|trace)"
    "debugger;"
)

# Pattern descriptions
pattern_descs=(
    "TODO comment found"
    "FIXME comment found"
    "Placeholder found"
    "XXX marker found"
    "HACK comment found"
    "Temporary code found"
    "Quick fix found"
    "'for now' comment found"
    "Simplified implementation found"
    "Ellipsis (...) found - possible incomplete code"
    "Merge conflict markers found"
    "Not implemented found"
    "Not implemented error found"
    "Debug console statement found"
    "Debugger statement found"
)

# File extensions to check
extensions="\.(js|ts|jsx|tsx|go|cpp|cc|h|hpp|rs|cs|java|py|rb|php|swift|kt|scala|vue|svelte)$"

# Directories to skip
skip_dirs="^\.|\.git|node_modules|dist|build|out|target|bin|obj|\.next|\.nuxt|coverage|\.nyc_output|vendor|\.autoclaude"

# Function to check a single file
check_file() {
    local file="$1"
    local line_num=0
    
    while IFS= read -r line; do
        ((line_num++))
        for i in "${!patterns[@]}"; do
            if echo "$line" | grep -qiE "${patterns[$i]}"; then
                errors+=("$file:$line_num - ${pattern_descs[$i]}")
            fi
        done
    done < "$file"
    
    # Check for empty catch blocks
    if grep -qE 'catch[[:space:]]*\([^)]*\)[[:space:]]*{[[:space:]]*}' "$file"; then
        warnings+=("$file - Empty catch block found")
    fi
    
    # Check for any type in TypeScript files
    if [[ "$file" =~ \.(ts|tsx)$ ]]; then
        local any_count=$(grep -o ':[[:space:]]*any\b' "$file" 2>/dev/null | wc -l || echo 0)
        if [ "$any_count" -gt 0 ]; then
            warnings+=("$file - Found $any_count uses of 'any' type")
        fi
    fi
}

# Main scanning function
scan_directory() {
    # Use find to get all files, excluding directories
    while IFS= read -r file; do
        # Make path relative to current directory
        relative_path="${file#./}"
        check_file "$relative_path"
    done < <(find . -type f -regex ".*$extensions" 2>/dev/null | grep -vE "/($(echo "$skip_dirs" | tr '|' '|'))/" || true)
}

# Start scanning
scan_directory

# Function to escape JSON strings
json_escape() {
    printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g; s/
/\\n/g; s//\\r/g'
}

# Function to escape JSON strings
json_escape() {
    printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g; s/
/\\n/g; s//\\r/g'
}

# Output results in JSON format
echo "{"
echo "  \"passed\": $([ ${#errors[@]} -eq 0 ] && echo "true" || echo "false"),"
echo "  \"errors\": ["
if [ ${#errors[@]} -gt 0 ]; then
    for i in "${!errors[@]}"; do
        echo -n "    \"$(json_escape "${errors[$i]}")\"" 
        if [ $i -lt $((${#errors[@]} - 1)) ]; then
            echo ","
        else
            echo
        fi
    done
fi
echo "  ],"
echo "  \"warnings\": ["
if [ ${#warnings[@]} -gt 0 ]; then
    for i in "${!warnings[@]}"; do
        echo -n "    \"$(json_escape "${warnings[$i]}")\"" 
        if [ $i -lt $((${#warnings[@]} - 1)) ]; then
            echo ","
        else
            echo
        fi
    done
fi
echo "  ],"
echo "  \"fixInstructions\": \"Remove all TODO/FIXME comments, placeholders, debug statements, and implement all incomplete code sections before deployment.\""
echo "}"
